{"description":"Laboratorio basato su Docker-compose per fare pratica con alcune tipologie di attacco e sulla identificazione dei suddetti attraverso l'utilizzo di IDS Suricata-based, e agire in modo appropriato con tecniche di remediation per salvaguardare il webserver di interesse.","goal":"<p>Scopo del laboratorio &egrave; quello di acquisire esperienza pratica nella configurazione di un Intrusion Detection System per il monitoring della sicurezza di rete.</p>\n<p>Il laboratorio prevede :</p>\n<ul>\n<li>Esecuzione dell'attacco da parte dell'attacker</li>\n<li>Identificazione dell'attacco sul nodo router</li>\n<li>Remediation relativa all'attacco che pu&ograve; essere eseguita o sul nodo router (ad esempio con un Firewall) oppure sul nodo webserver.</li>\n</ul>\n<p>Tali azioni vanno eseguite per alcuni tipi di attacco, quelli qui proposti sono:</p>\n<ul>\n<li>Scan</li>\n<li>Cross Site Scripting (XSS)</li>\n<li>DoS</li>\n<li>SQL injection</li>\n</ul>\n<p>&nbsp;</p>","solution":"<div class=\"markdown-heading\" dir=\"auto\">\n<h2 class=\"heading-element\" dir=\"auto\" tabindex=\"-1\">Attacchi in esame (Esecuzione attacco)</h2>\n<a id=\"user-content-attacchi-in-esame\" class=\"anchor\" href=\"https://github.com/Luigi810/SuricataLab#attacchi-in-esame\"></a></div>\n<p dir=\"auto\">Il laboratorio consiste nell'eseguire degli attacchi di diverso tipo sul webserver e riuscire a riconfigurare Suricata in modo da identificare e magari reagire ad una serie di tipologie di attacco quali</p>\n<ol dir=\"auto\">\n<li>lo scanning attraverso nmap, con i comandi</li>\n</ol>\n<p dir=\"auto\">nmap -sS 172.18.0.3</p>\n<p dir=\"auto\">nmap -sV 172.18.0.3</p>\n<ol dir=\"auto\" start=\"2\">\n<li>XSS sfruttando la pagina <a href=\"http://172.18.0.3/xssVuln.php\" rel=\"nofollow\">http://172.18.0.3/xssVuln.php</a> o <a href=\"http://172.18.0.3/xssVulnCookie.php\" rel=\"nofollow\">http://172.18.0.3/xssVulnCookie.php</a>. Per farlo da shell possiamo usare il comando curl come segue</li>\n</ol>\n<p dir=\"auto\">curl '<a href=\"http://172.18.0.3/xssVuln.php?comment=%3Cscript%3Ealert%28%27XSS%21%27%29%3C%2Fscript%3E\" rel=\"nofollow\">http://172.18.0.3/xssVuln.php?comment=%3Cscript%3Ealert%28%27XSS%21%27%29%3C%2Fscript%3E</a>'</p>\n<ol dir=\"auto\" start=\"3\">\n<li>Attacco DoS, sfruttando ad esempio il comando nella suite nmap</li>\n</ol>\n<p dir=\"auto\">nping --tcp-connect -p 80 --rate 1000 172.18.0.3 -c 10000</p>\n<p dir=\"auto\">dove -c in particolare specifica il numero di iterazioni dopo il quale fermarsi, il rate &egrave; il numero di pacchetti inviati al secondo, e ovviamente sono specificati IP destinazione, porta e tipo di connessione.</p>\n<ol dir=\"auto\" start=\"4\">\n<li>Attacco SQL Injection sfruttando la vulnerabilit&agrave; della pagina sqlVuln.phpdove &egrave; presente un form da compilare per poter accedere ad un database.Si pu&ograve; eseguire l'attacco da shell con il comando curl:</li>\n</ol>\n<p dir=\"auto\">curl "<a href=\"http://172.18.0.3/sqlVuln.php?user_id=1'OR+1%3D1+%23\" rel=\"nofollow\">http://172.18.0.3/sqlVuln.php?user_id=1'OR+1%3D1+%23"</a></p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">Ovviamente prima dell'esecuzione dell'attacco va innanzitutto creata e riempita la tabella del database MySql:</p>\n<p dir=\"auto\">-- Per fare il login in MySQL</p>\n<p dir=\"auto\">mysql -u user -p</p>\n<p dir=\"auto\">-- Per selezionare il database nel DBServer</p>\n<p dir=\"auto\">USE testdb;</p>\n<p dir=\"auto\">-- Per creare una table nel DB</p>\n<p dir=\"auto\">CREATE TABLE utenti ( id INT AUTO_INCREMENT PRIMARY KEY, nome VARCHAR(100) NOT NULL );</p>\n<p dir=\"auto\">-- Per inserire un valore nella tabella</p>\n<p dir=\"auto\">INSERT INTO utenti (nome) VALUES ('Kvaratskhelia');</p>\n<p dir=\"auto\">&nbsp;</p>\n<div class=\"markdown-heading\" dir=\"auto\">\n<h2 class=\"heading-element\" dir=\"auto\" tabindex=\"-1\">Possibili Regole Suricata per la loro identificazione (Identification)</h2>\n<a id=\"user-content-possibili-regole-suricata-per-la-loro-identificazione\" class=\"anchor\" href=\"https://github.com/Luigi810/SuricataLab#possibili-regole-suricata-per-la-loro-identificazione\"></a></div>\n<ol dir=\"auto\">\n<li>Per rilevare uno scan TCP Connect, che rispetti i vincoli temporali della seguente, pu&ograve; essere usata la regola:</li>\n</ol>\n<p dir=\"auto\">alert tcp any any -&gt; $HOME_NET any (msg:\"Nmap TCP Connect scan detected\"; flags:S,A; threshold: type both, track by_src, count 20, seconds 3; classtype:attempted-recon; sid:100002; rev:1;)</p>\n<ol dir=\"auto\" start=\"2\">\n<li>Per rilevare un attacco XSS in cui si inserisce il tag html per incorporare codice senza modifiche pu&ograve; essere:</li>\n</ol>\n<p dir=\"auto\">alert http any any -&gt; $HOME_NET any (msg:\"XSS Attack Detected: Basic script tag\"; flow:to_server,established; content:\"&lt;script&gt;\"; http_uri; nocase; classtype:web-application-attack; sid:1000004; rev:1;)</p>\n<ol dir=\"auto\" start=\"3\">\n<li>Per rilevare l'attacco SYN flood (attacco DoS), che rispetti i vincoli temporali della seguente, pu&ograve; essere usata la regola:</li>\n</ol>\n<p dir=\"auto\">alert tcp any any -&gt; $HOME_NET 80 (msg:\"SYN Flood Detected\"; flags:S; threshold: type both, track by_src, count 200, seconds 1; classtype:attempted-dos; sid:1000005; rev:1;)</p>\n<ol dir=\"auto\" start=\"4\">\n<li>Per rilevare questo particolare Attacco SQL Injection una possibile regola per l'identificazione &egrave;</li>\n</ol>\n<p dir=\"auto\">alert http any any -&gt; $HOME_NET any (msg:\"SQL Injection Attempt - OR 1=1 URL-encoded\"; content:\"OR+1%3D1\"; nocase; classtype:web-application-attack; sid:1000011; rev:1;)</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<div class=\"markdown-heading\" dir=\"auto\">\n<h2 class=\"heading-element\" dir=\"auto\" tabindex=\"-1\">Remediation</h2>\n<p>&nbsp;</p>\n<ol dir=\"auto\">\n<li>Se si identifica un IP sospetto che effettua scansioni, &egrave; possibile bloccare il traffico da quell&rsquo;IP con una regola di iptables. In questo caso quindi si pu&ograve; eseguire il comando seguente per bloccare il traffico proveniente dal suddetto IP sospetto.</li>\n</ol>\n<p dir=\"auto\"><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iptables -A INPUT -s 172.19.0.3 -j DROP<br />La soluzione pi&ugrave; tempestiva consiste nel configurare Suricata in modalit&agrave; IPS cos&igrave; che possa rilevare scansioni tramite regole specifiche e automaticamente bloccare le richieste sospette, inoltre &egrave; una soluzione pi&ugrave; resistente se non sono noti gli indirizzi IP degli attaccanti a priori (come solitamente succede, talvolta con IP falsificati).<br />Nella modalit&agrave; IPS, Suricata non si limita a rilevare, ma pu&ograve; anche bloccare il traffico in base alle regole configurate. Per attuare questa soluzione sono richieste modifiche al file suricata.yaml, bisogna aggiungere una regola di tipo drop al file suricata.rules o aggiungere un nuovo file in cui tali regole sono contenute, come emerging-scan.rules, alla lista di rules files dopo aver abilitato le regole di drop, ed infine lanciare normalmente Suricata.<br />Di seguito una soluzione possibile con l&rsquo;utilizzo di Suricata in modalit&agrave; IPS: Come documentato nella Documentazione di Suricata per avere suricata in modalit&agrave; IPS tra le interfacce eth0 ed eth1 serve la seguente configurazione di af-packet: modifica alla sezione af-packet in /etc/suricata/suricata.yaml<br />...<br />&nbsp; af-packet:<br />&nbsp;&nbsp;&nbsp; - interface: eth0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threads: 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defrag: yes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster-type: cluster_flow<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster-id: 98<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy-mode: ips<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy-iface: eth1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer-size: 64535<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use-mmap: yes<br />&nbsp;&nbsp;&nbsp; - interface: eth1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threads: 1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster-id: 97<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defrag: yes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster-type: cluster_flow<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy-mode: ips<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy-iface: eth0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer-size: 64535<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use-mmap: yes<br />...</p>\n<p>&nbsp;&nbsp;&nbsp; /etc/suricata/rules/suricata.rules (regola drop all&rsquo;identificazione di uno scan)</p>\n<p><br />&nbsp;&nbsp;&nbsp; drop tcp any any -&gt; $HOME_NET any (msg:\"Nmap TCP Connect scan detected\"; flags:S,A; threshold: type both, track by_src, count 20, seconds 3; classtype:attempted-recon; sid:100020; rev:1;)</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<ol dir=\"auto\" start=\"2\">\n<li>Gli attacchi XSS sfruttano la mancanza di validazione o sanificazione dell&rsquo;input nelle<br />pagine web per inserire codice malevolo che viene poi eseguito nel browser degli utenti.<br />La remediation per XSS si concentra principalmente sulla corretta gestione degli input e<br />output in una pagina web.</li>\n</ol>\n<p>&nbsp;</p>\n<p><br />Per prevenire tali attacchi, &egrave; necessario intervenire direttamente sul codice dell&rsquo;applicazione web.<br />Un modo semplice ed efficace per prevenire gli attiacchi XSS &egrave; trasformare i caratteri speciali (&lt;, &gt;, \", &rsquo;, &amp;, ecc.) all&rsquo;interno dell&rsquo;input in entit&agrave; HTML. In PHP pu&ograve; essere sfruttata a tal scopo la funzione htmlspecialchars(). Oppure si possono aggiungere controlli sull&rsquo;input dell&rsquo;utente per accettare solo dati di un formato prestabilito (ad esempio solo testo e spazi). La pagina xssVuln.php pu&ograve; quindi essere riscritta come segue sfruttando la funzione htmlspecialchars() per sanificare gli user input.</p>\n<p><br />...<br />&nbsp;&nbsp;&nbsp; &lt;div&gt;<br />&nbsp;&nbsp;&nbsp; &lt;p&gt;&lt;?php<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(isset($_GET[&rsquo;comment&rsquo;])) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; $comment = htmlspecialchars($_GET[&rsquo;comment&rsquo;], ENT_QUOTES, &rsquo;UTF-8&rsquo;);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; echo $comment;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; ?&gt;&lt;/p&gt;<br />&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br />...</p>\n<p><br />Una soluzione alternativa potrebbe sfruttare le RegEx per validare l&rsquo;input ed imporre dei constraints relativi alla forma.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<ol dir=\"auto\" start=\"3\">\n<li>Analogamente a quanto succede per l&rsquo;attacco scan, se si identifica un IP sospetto che genera un traffico anomalo, &egrave; possibile bloccare tale traffico proveniente da quell&rsquo;IP con una regola di iptables. In questo caso quindi si pu&ograve; eseguire il comando seguente per bloccare il traffico proveniente dal suddetto ip sospetto.</li>\n</ol>\n<p>&nbsp;</p>\n<p>iptables -A INPUT -s 172.19.0.3 -j DROP</p>\n<p><br />Oppure tramite l&rsquo;azione di Suricata in modalit&agrave; IPS, come visto per la remediation per gli scan, aggiungendo la regola</p>\n<p><br />drop tcp any any -&gt; $HOME_NET 80 (msg:\"SYN Flood Detected\"; flags:S; threshold: type both, track by_src, count 200, seconds 1; classtype:attempted-dos; sid:1000005; rev:1;)</p>\n<p>Altro metodo con iptables per evitare che il traffico anomalo generi un sovraccarico del servizio, consiste nel limitare il numero di connessioni HTTP (ossia sulla porta 80) ad esempio a 25 al minuto.</p>\n<p>iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT</p>\n<p>Entrambe per&ograve; non risolvono del tutto il problema della availability se l&rsquo;attacco DoS &egrave; distribuito.<br />Oppure, come visto nel paragrafo di remediation per gli scan, tramite l&rsquo;azione di Suricata in modalit&agrave; IPS (con configurazione analoga a quella del paragrafo Attacchi-&gt;Scan-&gt;Remediation) aggiungendo la regola</p>\n<p>drop tcp any any -&gt;$HOME_NET 80 (msg:\"SYN Flood Detected\"; flags:S; threshold: type both, track by_src, count 200, seconds 1;<br />classtype:attempted-dos; sid:1000005; rev:1;)</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<ol dir=\"auto\" start=\"4\">\n<li>Separando l&rsquo;input dalla query e aggiungendo una validazione dell&rsquo;input, si pu&ograve; migliorare la struttura del codice e proteggere la pagina da SQL injection. Si possono quindi sfruttare i Prepared Statements, ossia delle query parametrizzate in cui si separano gli user input da una query con struttura fissa usata per eseguire la stessa interrogazione ripetitivamente con alta efficienza e soprattutto permette la protezione dalle SQL injections. La pagina sqlVuln.php quindi pu&ograve; essere riscrivere come segue sfruttando un prepared statement.</li>\n</ol>\n<p>La pagina sqlVuln.php quindi pu&ograve; essere riscrivere come segue sfruttando un prepared statement.</p>\n<p>...</p>\n<p><br />&nbsp;&nbsp;&nbsp; &lt;?php<br />&nbsp;&nbsp;&nbsp; // Configurazione del database<br />&nbsp;&nbsp;&nbsp; $servername = \"10.0.0.4\";&nbsp; // IP del container del database<br />&nbsp;&nbsp;&nbsp; $username = \"user\";<br />&nbsp;&nbsp;&nbsp; $password = \"password\";<br />&nbsp;&nbsp;&nbsp; $dbname = \"testdb\";<br /><br />&nbsp;&nbsp;&nbsp; // Creazione della connessione<br />&nbsp;&nbsp;&nbsp; $conn = new mysqli($servername, $username, $password, $dbname);<br /><br />&nbsp;&nbsp;&nbsp; // Controllo della connessione<br />&nbsp;&nbsp;&nbsp; if ($conn-&gt;connect_error) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; die(\"Connessione al database fallita: \" . $conn-&gt;connect_error);<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; // Funzione di validazione dell'input<br />&nbsp;&nbsp;&nbsp; function validaInput($data) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Controlliamo se il campo &egrave; vuoto<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (empty($data)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Rimuoviamo eventuali spazi bianchi<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $data = trim($data);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Filtriamo caratteri non desiderati (solo lettere e spazi)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!preg_match(\"/^[a-zA-Z ]*$/\", $data)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $data;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; // Verifica se &egrave; stato inviato un parametro tramite GET<br />&nbsp;&nbsp;&nbsp; if (isset($_GET['user_id'])) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $user = validaInput($_GET['user_id']);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ($user === false) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo \"Input non valido. Assicurati di inserire solo caratteri alfabetici.\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Preparazione della query sicura con prepared statements<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $stmt = $conn-&gt;prepare(\"SELECT * FROM utenti WHERE nome = ?\");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $stmt-&gt;bind_param(\"s\", $user);&nbsp; // \"s\" indica che si tratta di una stringa<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Esecuzione della query<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $stmt-&gt;execute();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $result = $stmt-&gt;get_result();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Controllo del risultato<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ($result-&gt;num_rows &gt; 0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Output dei dati di ciascuna riga<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ($row = $result-&gt;fetch_assoc()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo \"ID: \" . $row[\"id\"] . \" - Nome: \" . $row[\"nome\"] . \"&lt;br&gt;\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo \"0 risultati trovati\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Chiusura dello statement<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $stmt-&gt;close();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; // Chiusura della connessione<br />&nbsp;&nbsp;&nbsp; $conn-&gt;close();<br />&nbsp;&nbsp;&nbsp; ?&gt;</p>\n<p>...</p>\n<p>&nbsp;</p>\n<p>Come si pu&ograve; notare dal codice la query \"SELECT * FROM utenti WHERE nome = ?\" presenta un parametro (ossia il &rsquo; ?&rsquo;) che &egrave; affidato alla variabile user, la quale &egrave; ottenuta dal parametro user_id inserito dall&rsquo;utente ed inglobato nell&rsquo;URL.<br />Tale parametro prima di essere unito (attraverso la funzione bind_param()) alla query viene prima passato alla funzione validaInput() che controlla che il parametro in ques- tione rispetti la forma specificata attraverso la Regular Expression (RegEx) \"/&circ;[a-zA-Z ]*$/\" che impone l&rsquo;uso di sole lettere minuscole, maiuscole oppure spazi senza vincoli sulla dimensione.<br />Infine, dopo aver legato il parametro alla struttura predeterminata con bind_param(), la query viene inoltrata al database tramite l&rsquo;utilizzo del metodo execute().</p>\n<a id=\"user-content-possibili-regole-suricata-per-la-loro-identificazione\" class=\"anchor\" href=\"https://github.com/Luigi810/SuricataLab#possibili-regole-suricata-per-la-loro-identificazione\"></a></div>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p dir=\"auto\">&nbsp;</p>\n<p>&nbsp;</p>","readme":"Si possono trovare tutte le informazioni relative al laboratorio nella documentazione ad esso relativa presente su Github:   https://github.com/Luigi810/SuricataLab/blob/main/ProgettoNS_Guerrera(26p).pdf","author":"Luigi810"}
